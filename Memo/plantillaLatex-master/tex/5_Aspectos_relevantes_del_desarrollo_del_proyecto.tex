\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}
\section{Ciclo de vida}
La realización de este trabajo se ha llevado a cabo en sprints de una duración de 14 días con reuniones entre sprint y sprint, y con frecuencia han habido reuniones a mitad de estos.

El proyecto empezó sintetizando una lista de aspectos a comprobar en los cursos Moodle a partir del marco de referencia de calidad del e-learning de MOOQ \cite{stracke2018quality} y un documento interno de UBUCEV proporcionado por los tutores.
Después tuve que decidir si crear una aplicación de escritorio o una aplicación web y qué framework utilizar para desarrollar la aplicación.
A partir de ahí, se hizo un prototipo para comprobar que era capaz de acceder a los web services de Moodle desde mi aplicación. Este prototipo solo mostraba la lista de cursos accedidos recientemente a partir de unas credenciales para la página de demostración de Moodle llamada Mount Orange School. Más tarde establecí el ciclo de integración continua/despliegue continuo y lancé la aplicación en Heroku. Una semana después, al final del sprint había creado una versión del informe específico que solo realizaba una comprobación sobre los cursos. A partir de ahí, debido a las fechas (segunda quincena de diciembre) no hubo ninguna reunión con los tutores hasta la vuelta de las vacaciones de navidad. Durante ese periodo, añadí el resto de las comprobaciones al informe y me dediqué a completar partes de la memoria.

\section{Proceso de obtención de llamadas a los servicios web}
Para obtener la información necesaria para las comprobaciones sobre los cursos de Moodle he tenido que realizar llamadas REST a distintas funciones de la API de servicios web de Moodle \cite{wsapifunctions-2021}. Sin embargo, la tabla que detalla la lista de funciones de la API omite los parámetros necesarios para las llamadas a las funciones.
Para averiguar qué parametros debía utilizar en cada función tuve que acceder al repositorio de Moodle \cite{moodlerepository-2022} y encontrar las funciones que detallaban el funcionamiento de la función de la API en la que estaba interesado cada vez.
El nombre de una función se puede dividir en dos partes: el nombre del componente que posee la función, y el nombre de la función. Las funciones están escritas en PHP y aparecen dentro de los archivos llamados "externallib.php". Para cada función existen tres funciones asociadas: <NOMBRE DE LA FUNCIÓN>, <NOMBRE DE LA FUNCIÓN>\_parameters, y <NOMBRE DE LA FUNCIÓN>\_returns.
La función a secas define el comportamiento de la función, y en su declaración se puede ver qué parámetros son opcionales y cuáles no.
La función con ''parameters'' al final describe los nombres y los tipos de datos de los parámetros que espera recibir la función.
La función con ''returns'' al final describe los nombres y los tipos de datos de los atributos que devuelve la función.
Por ejemplo, si quiero averiguar como llamar a la función mod\_forum\_get\_forums\_by\_courses
tengo acceder al fichero /mod/forum/externallib.php (supuesto por el nombre del componente que contiene la función, ''mod\_forum'' en este caso) y buscar las funciones get\_forums\_by\_courses, get\_forums\_by\_courses\_parameters, y get\_forums\_by\_courses\_returns.

Para probar el funcionamiento de las llamadas y al mismo tiempo obtener las clases que debía definir como POJO para manejar los datos recibidos como JSON (JSON (JavaScript Object Notation), es una forma de representar un objeto en formato de texto muy usado para transmitir información en aplicaciones web), hice lo siguiente:
Uso la página de demostración de Moodle llamada Mount Orange School para hacer pruebas.
Hago llamadas REST de forma manual con el navegador Chrome y obtengo el token con las credenciales de profesor (usuario:''teacher'' contraseña:''moodle'')\imagen{Token.png}{Obtención del token}. Después utilizo el token para la siguiente llamada y obtengo una respuesta en formato JSON. \imagen{JSON.png}{Obtención del JSON} Copio la respuesta en un conversor de JSON a POJO.\imagen{Conversor.png}{Uso del conversor} Creo las clases correspondientes, añado un constructor vacío y encapsulo los atributos. 


\section{Integración continua y despliegue continuo}
La integración continua consiste en la automatización de la compilación y ejecución de pruebas cada vez que se suben cambios al repositorio.
El despliegue continuo es la automatización del despliegue de un producto tras cada cambio en el repositorio.
He implementado la integración continua del proyecto con GitHub Actions, primero, establecí en el archivo pom.xml que la compilación del proyecto fuera en formato WAR (Web Application Resource), luego, creé el archivo "maven.yml" en la carpeta de workflows para establecer que cada vez que se realice un push en la rama principal el proyecto se compile y se ejecuten los tests con Maven.
He implementado el despliegue continuo en Heroku, la mayoría del proceso ha sido bastante intuitiva, ya que una de las opciones que ofrecía era GitHub como método de despliegue pero debido a que mi repositorio contiene por un lado la memoria y por otro el proyecto software, he tenido que añadir un buildpack (conjuntos de scripts de codigo abierto usados para compilar las aplicaciones en Heroku) que permite especificar una subcarpeta del repositorio para usarla como directorio raíz del proyecto software. También establecí en las opciones que el despliegue automático espere a que se supere la integración continua.


